# 实例进阶

* 一切数据都是通过变量管理的
* 实例也是一个变量，他也是放在内存中的
* 当我们实例化一个对象的时候，其实就是将构造函数的属性拷贝一份，同时在内存中开辟一个新的区域保存这些值
*  当我们创建一个构造函数时，并不会分配内存，只有在实例化的时候才会分配内存


#　实例进阶

## 实例拷贝
### 指针概念：
当我们定义一个变量时，会在内存中开辟一段区域以存储这个变量的值，每个内存区域都有一个对应的地址，我们一般通过地址来找到这个变量的值。就相当于门牌号

### 对象是如何在内存中存储的
在内存中开辟两片区域，一片区域存储变量名称（地址），另一段区域存储的才是实例真正的值。实例名称当中存储的只是地址，具体内容放在另一块区域里面

### constructor（用来判断实例化对象的构造函数）
* constructor是构造函数的一个隐藏属性
* 为什么实例也拥有这个属性呢？（因为实例化对象 的时候，会将构造函数的全部属性（包含自定义的和系统自动生成的）拷贝一份，同时赋值给新值。因为有的构造函数有默认值，一旦你给实例赋予了新值，就会将内存空间替换掉）




# 原型进阶
### 构造函数创建对象存在的问题
* 为了避免内存浪费，所以出现了原型帮我们解决这个问题
* 原型对象，不管你实例化多少次，都只生成一次。（主要是为了共享方法，【方法】某种程度上也是属性）
* 实例化的时候只拷贝构造函数中的属性（方法），不拷贝原型对象中的属性（方法）。通过_proto_来访问原型对象中的属性和方法

### 原型对象本质
* 原型对象的所有属性和方法和属性可以被所有实例共享
* 所以呢，如要修改所有实例中的属性和方法，直接修改一次就可以了（因为其共享同一个原型对象，操作的是同一片内存区域，改一处，所有的实例都要改【其会往原型上找时】）
 
### 属性搜索机制
* 先在自身属性列表中查找，如果找到直接返回
* 如果找不到，先找到自身的一个隐藏属性prototype，这个属性中保存的是原型对象的地址

### 属性搜索机制的本质（通过prototype属性中保存的地址链接到原型）
* 任何一个我们编写的函数其实都是Function对象
* 既然对象是函数实现的，那么对象当然也是Function的一个实例
* 所有构造函数含有Function对象中的一切属性和方法
* 而constructor属性prototype属性是Function对象中的属性之一
* 而实例化的时候会拷贝构造函数中的属性和方法，自然就有了constructor属性prototype属性
* prototype属性：保存的就是地址（作用：将实例和原型对象链接在一起）

### 双对象法则
* 所谓的双对象包含两个独立的对象：构造函数对象，原型对象
* 这俩对象是通过一个叫_proto_的属性联系起来的（_proto_已经成为ES5的一种标准）
* 构造函数通过_proto_指向原型对象

### 属性屏蔽理论
* 第一 要会用属性搜索法则寻找出访问属性的链条
* 第二 如果我们想访问原型中被屏蔽掉的属性有俩种方法
	* delete product.name
	* 使用Product.prototype.name(name 可为属性或方法) 